<h1 id="books-authors---nam-dao---nhd36">Books | Authors - Nam Dao -
nhd36</h1>
<h2 id="submission-hw1">Submission HW1</h2>
<h4 id="design">Design</h4>
<ol type="1">
<li>How did you structure your API’s requests and responses?</li>
</ol>
<ul>
<li>I separated an API into two separate layers, which I usually did
when I was working with Java or Python web server: Controller and
Service.</li>
<li>Controller: I used this layer to parse the data from request and
modify their types to get the type that I desired for further
processing. Data from multiple sources such as Path Params, Query
Params, Headers, Body, …</li>
<li>Service: I used this layer to communicate with database, making
query and logic should be appear in this layer.</li>
</ul>
<ol start="2" type="1">
<li>How did you validate inputs, what restrictions did you choose, and
why?</li>
</ol>
<ul>
<li>For validating input, Controller layer should be part to do data
validation, check type and parse type into good shape before transfering
it to the Service layer to interact with database.</li>
<li>Restriction I chose mostly related to data type, as it may cost
error when interacting with database. With that being said, these
restrictions will prevent the application to crash in the middle of
process.</li>
</ul>
<ol start="3" type="1">
<li>What edge cases did you handle and how? What edge cases did you
choose not to handle?</li>
</ol>
<ul>
<li>Most of the edge case I handled was about corresponding datatype
with database column. I do data validation and parsing into the correct
type so when the data interacted with database, it would not crash
anything.</li>
<li>Edge case that I did not choose to handle is data appears to be
NULL. The reason I am not handling those case is because there is no
restriction in original schema regarding column must be NOT NULL. With
that being said, even if inputting NULL data into the database, it would
not cause any issue or crash the program.</li>
</ul>
<h4 id="typescript">Typescript</h4>
<ol type="1">
<li>Keep track of the bugs Typescript helped you catch and the ones it
didn’t catch. What are some of the issues Typescript helped you prevent?
What are some of the holes in the type system?</li>
</ol>
<ul>
<li><p>Type static is always favorable compare to dynamic type, as it
helps us to specify the type that we want to use in specific case. For
me, in this project, the best thing I have experienced from Typescript
is that the static type helped me avoiding so many bugs related to data
type, which happens to me a lot when I was working with
Javascript.</p></li>
<li><p>During my development process, I noticed that there is a bug when
I parse the variable from the request to the desirable type.
&lt;Number&gt;req.body.variable_name should return us the
<strong>Number</strong> variable. However, instead, it gave me string.
The annoying thing is that when I put this variable into an object with
interface that set the variable to be Number also accept a string value,
which should not be allowed? I have to made extra effort of parsing the
string into number. Lucky for me, everything works fine.</p></li>
</ul>
<ol start="2" type="1">
<li>What kinds of values did you struggle to type correctly? Are there
any Typescript topics that are still confusing you?</li>
</ol>
<ul>
<li>I don’t find Typescript is confusing. I think is superb comparing to
Javascript because of static type, better control of data flow and data
type for every variable. At first, I was a little bit struggling with
how to run Typescript, as I was expecting it to compile directly without
translating them into Javascript. It took me a while to understand the
purpose of <strong>out</strong> directory, as I keep deleting them after
every build.</li>
</ul>
<h4 id="testing">Testing</h4>
<ol type="1">
<li>What was your experience writing tests? Was it boring, soothing,
rewarding? How did they affect your development process?</li>
</ol>
<ul>
<li>It was exhausting process. I wrote 40+ test cases with nearly new
1000 lines of code. It is really time consuming but helped me realizing
some of the potential bugs and fix them. It was kind of soothing and
rewarding in the end, when I finished my last test case, I feel pretty
relief.</li>
</ul>
<ol start="2" type="1">
<li>Did your tests help you find any bugs? If so, which ones?</li>
</ol>
<ul>
<li>Mostly not, all of my code was manually tested during the
development process, so I don’t really find any bugs along the way. Some
of the API returns unclear status code, so I just modify them.</li>
</ul>
<ol start="3" type="1">
<li>How would you structure your testing differently in the future? What
did you learn while testing?</li>
</ol>
<ul>
<li>This is the test structure that I used in every coding project. I
think it is pretty reasonable to split each API service into different
testing sections.</li>
<li>For now, I am still looking over some sample to see if I can improve
anything. One thing that I know that I need to improve is how I
structure the test cases. Right now, the test cases of the whole
projects are lying in just 1 file. However, I believe that we can split
them into different files, maybe folders, for better maintaining and
improving readability. I am hurting my eyes just to look over 1000 lines
of code to find the part that I want to fix.</li>
</ul>
<h2 id="submission-hw2">Submission HW2</h2>
<h4 id="design-1">Design</h4>
<ol type="1">
<li>Keep track of the changes you made to your back-end as you
implemented your front-end. What changes did you need to make and why?
Would you structure your back-end differently in the future?</li>
</ol>
<ul>
<li>I didn’t really make any changes in Back End structure.</li>
<li>However, I still believe that it is a mess and will need so rework
in the future. Right now, I am putting the database integration with all
<strong>service</strong> folder. However, in the future, I will separate
it into a separate folder that only in charge of communicating data with
the database.</li>
</ul>
<ol start="2" type="1">
<li>How did you structure the UI of your search inputs and forms? What
choices did you make and why?</li>
</ol>
<ul>
<li>As for me, I found it pretty hard to think of the way how to design
a structure for Front End components in order to reuse multiple
functionalities. Personally, I did not code with React really often, so
I need to take some reference from the website of how they structure
components in the project.</li>
</ul>
<ol start="3" type="1">
<li>Did you perform client-side validation or did you rely on
server-side validation alone? What are the pros/cons of making either
choice?</li>
</ol>
<ul>
<li>I leave the validation to the server-side. The client-side only in
charge of passing data to the API and display the response that the APIs
return.</li>
<li>I think the pros would just be more secure towards data type, I
don’t think there is much difference between client-side validation and
server-side validation.</li>
</ul>
<h4 id="react">React</h4>
<ol type="1">
<li>What was your experience manipulating state with React components
(especially with the useEffect hook)? What kinds of things did you
struggle with?</li>
</ol>
<ul>
<li>My biggest struggle was deploying the React with Express server.
Since I am using external library called
<strong>react-router-dom</strong>, this conflicts with how Express works
as React did not generate the folder structure that Express wants in
order to render the public folder. So I tried but it did not give me any
green light, so I make a little alternation in rendering components by
removing <strong>react-router-dom</strong> and render by state
instead.</li>
</ul>
<ol start="2" type="1">
<li>What was your experience using types with the front-end? Did they
catch any bugs? Did you have to make a lot of manual annotations? Did
you resort to using any frequently, and if so, why?</li>
</ol>
<ul>
<li>I find it pretty annoying when for some datatype, I could not figure
it out the way to parse the data into the desired datatype. I didn’t
catch any bugs due to Typescript neither, so I think the experience is
pretty mediocre.</li>
<li>I didnt use <strong>any</strong> frequently. In fact, I didn’t use
<strong>any</strong>. I make a lot of manual <strong>Type</strong> and
trying to parse data to those following types.</li>
</ul>
<ol start="3" type="1">
<li>Compare and contrast your experiences writing an SPA front-end with
React to writing a MPA front-end like we did in CS375.</li>
</ol>
<ul>
<li>I didn’t take CS375 with you so I don’t really sure what you are
referring to. But running SPA with Express is definitely better
experience than MPA due to the way that React’s build folder. The way
that Express expose its static folder is by file structure, which means
that index.html is always the first choice when people visit
http://{domain_name}:{port}/. If you want to add path variables, you
need to make sure that the folder matching with that path variables
exists.</li>
<li>React only renders index.html and whole bunch of JS and CSS. There
is no file structure, so Express could not work with
<strong><em>react-router-dom</em></strong>.</li>
</ul>
<h2 id="submission-hw3">Submission HW3</h2>
<h4 id="ui">UI</h4>
<ol type="1">
<li>How did you integrate the book editing and deletion into your UI?
Why did you choose the design you did?</li>
</ol>
<ul>
<li>For PUT, I just set another form that required user to choose 1 row
data on the table and edit that data. If the user does not choose any
row data in the table, I disabled all the button.</li>
<li>For DELETE, I add 1 more column in each row of data a button. Each
button is associated with its data ID that will call the API with axios
if clicked and result in deleting that specific data point.</li>
<li>I noticed that the PUT endpoint is pretty similar to CREATE, so I
decided to implement it that way. For DELETE, I think each row of data
can directly have a button next for it so the user is easier to follow
and it also have a better navigation around the page, without causing
too complicated UI.</li>
</ul>
<ol start="2" type="1">
<li>How difficult was book editing/deletion to implement?</li>
</ol>
<ul>
<li>It was not really hard to implement. But since I suck at splitting
up the components and managing state flows through the DOM tree, I have
to make some changes for the states to be passed properly down from the
root tree, so it causes a mess at the first time and need to clarify a
lot.</li>
</ul>
<h4 id="material-ui">Material UI</h4>
<ol type="1">
<li>How easy was it to refactor your existing UI to use Material UI?
What pitfalls did you run into trying to use it?</li>
</ol>
<ul>
<li>I was using Material UI on the original, but I don’t have any
comment for this question. However, I know one thing is that Material UI
gives me a speedy development. All the component that we try to
customize with raw HTML and CSS has already been available in Material
UI libraries. We just need to call the API and make a few changes from
the MUI components to have a full completed version of UI. Moreover, it
is very reusable and we can use anywhere that we want.</li>
</ul>
<h4 id="material-ui-1">Material UI</h4>
<ol type="1">
<li>How difficult was it to add the PUT endpoint and associated tests?
Did your experience writing the POST endpoints make writing the PUT
endpoints smoother?</li>
</ol>
<ul>
<li>I wrote test for PUT when I was working on HW1 so I don’t think that
it was hard to add PUT endpoint and its associated tests. Typically, it
is just POST endpoint with the ability to check the existence and its
other associated data to make sure that the newly added data satisfies
the integrity of the database.</li>
<li>Yeah, I copy/paste POST endpoints and add more features to make PUT
endpoints.</li>
</ul>
<h2 id="submission-hw4">Submission HW4</h2>
<h4 id="ui-1">UI</h4>
<ol type="1">
<li>How did you integrate authorization into your UI? How did you
prevent or warn users when they weren’t authorized to perform an
action?</li>
</ol>
<ul>
<li>I implement authorization by adding another authorize middleware
into each API, so if they don’t have the required Cookies and contains
the right type of token, Backend API will throws 401 status code with
unauthorized message.</li>
<li>For Frontend, I only rendered components once the user successfully
authorized with Authorization API. If the user fails to authorize, only
sign in / sign up component will be rendered.</li>
</ul>
<ol start="2" type="1">
<li>What did you struggle with when adding logins and authorization to
your front-end?</li>
</ol>
<ul>
<li>I didn’t really have any trouble trying to implement the
authorization. The hardest thing I tried to figure it out is how to add
authorize middleware into each router.</li>
</ul>
<h4 id="login-endpoint">Login endpoint</h4>
<ol type="1">
<li>What did you struggle with when adding logins and authorization to
your back-end?</li>
</ol>
<ul>
<li>Same as above, I did not have a lot of difficulties with this
homework.</li>
</ul>
<h2 id="api-endpoints">API Endpoints</h2>
<h4 id="books-api">Books API</h4>
<ul>
<li>Get all books by filter pub_year or title</li>
</ul>
<pre><code>GET &lt;http://{domain_name}:3000/books?from=&amp;to=&amp;title=&gt;

* Request:
- Query param:
{
    from: &lt;int&gt; - optional,
    to: &lt;int&gt; - optional,
    title: &lt;string&gt; - optional
}

* Response:

- &lt;200&gt; success:
{
    data: [
        {
            id: &lt;string&gt;,
            title: &lt;string&gt;,
            pub_year: &lt;int&gt;,
            genre: &lt;string&gt;,
            author_id: &lt;string&gt;
        },
        ...
    ],
    status_code: 200
    message: &lt;string&gt;
}

- &lt;non-200&gt; failed:
{
    data: null,
    status_code: &lt;non-200 status code&gt;
    message: &lt;string_error&gt;
}</code></pre>
<ul>
<li>Get 1 book by ID</li>
</ul>
<pre><code>GET &lt;http://{domain_name}:3000/books/{book_id}&gt;
* Request:
- Path param:
{
    book_id: &lt;int&gt;
}

* Response: 
- &lt;200&gt; success:
{
    data: {
        id: &lt;string&gt;,
        title: &lt;string&gt;,
        pub_year: &lt;int&gt;,
        genre: &lt;string&gt;,
        author: &lt;string&gt;
    },
    status_code: 200
    message: &lt;string&gt;
}
- &lt;non-200&gt; failed:
{
    data: null,
    status_code: &lt;non-200 status code&gt;
    message: &lt;string_error&gt;
}</code></pre>
<ul>
<li>Create 1 book</li>
</ul>
<pre><code>POST &lt;http://{domain_name}:3000/books&gt;
* Request:

- Headers: 
{
    Content-Type: application/json
}

- Body:
{
    title: &lt;string&gt;,
    pub_year: &lt;int&gt;,
    genre: &lt;string&gt;,
    author: &lt;string&gt;
}

* Response:

- &lt;200&gt; success:
{
    data: {
        id: &lt;string&gt;,
        title: &lt;string&gt;,
        pub_year: &lt;int&gt;,
        genre: &lt;string&gt;,
        author: &lt;string&gt;
    },
    status_code: 200
    message: &lt;string&gt;
}

- &lt;non-200&gt; failed:
{
    data: null,
    status_code: &lt;non-200 status code&gt;
    message: &lt;string_error&gt;
}</code></pre>
<ul>
<li>Delete 1 book by ID</li>
</ul>
<pre><code>DELETE &lt;http://{domain_name}:3000/books/{book_id}&gt;
* Request:
- Path param:
{
    book_id: &lt;int&gt;
}

* Response: 
- &lt;200&gt; success:
{
    data: null,
    status_code: 200
    message: &lt;string&gt;
}
- &lt;non-200&gt; failed:
{
    data: null,
    status_code: &lt;non-200 status code&gt;
    message: &lt;string_error&gt;
}</code></pre>
<ul>
<li>Update 1 book</li>
</ul>
<pre><code>PUT &lt;http://{domain_name}:3000/books/{bookId}&gt;
* Request:

- Path Param:
{
    bookId: &lt;string&gt;
}

- Headers: 
{
    Content-Type: application/json
}

- Body:
{
    title: &lt;string&gt; - optional,
    pub_year: &lt;int&gt; - optional,
    genre: &lt;string&gt; - optional,
    author: &lt;string&gt; - optional
}

* Response:

- &lt;200&gt; success:
{
    data: null,
    status_code: 200
    message: &lt;string&gt;
}

- &lt;non-200&gt; failed:
{
    data: null,
    status_code: &lt;non-200 status code&gt;
    message: &lt;string_error&gt;
}</code></pre>
<h4 id="authors-api">Authors API</h4>
<ul>
<li>List and filter for authors by prefix author’s name</li>
</ul>
<pre><code>GET &lt;http://{domain_name}:3000/authors?name=&gt;

* Request:
- Query param:
{
    name: &lt;string&gt; - optional
}

* Response:
- &lt;200&gt; success:
{
    data: [
        {
            id: &lt;string&gt;,
            name: &lt;string&gt;,
            bio: &lt;string&gt;
        },
        ...
    ],
    status_code: 200
    message: &lt;string&gt;
}

- &lt;non-200&gt; failed:
{
    data: null,
    status_code: &lt;non-200 status code&gt;
    message: &lt;string_error&gt;
}</code></pre>
<ul>
<li>Get 1 author by ID</li>
</ul>
<pre><code>GET &lt;http://{domain_name}:3000/authors/{author_id}&gt;
* Request:
- Path param:
{
    author_id: &lt;int&gt;
}

* Response: 
- &lt;200&gt; success:
{
    data: {
        id: &lt;string&gt;,
        name: &lt;string&gt;,
        bio: &lt;string&gt;
    },
    status_code: 200
    message: &lt;string&gt;
}
- &lt;non-200&gt; failed:
{
    data: null,
    status_code: &lt;non-200 status code&gt;
    message: &lt;string_error&gt;
}</code></pre>
<ul>
<li>Create 1 author</li>
</ul>
<pre><code>POST &lt;http://{domain_name}:3000/authors&gt;
* Request:

- Headers: 
{
    Content-Type: application/json
}

- Body:
{
    name: &lt;string&gt;,
    bio: &lt;string&gt;
}

* Response:

- &lt;200&gt; success:
{
    data: {
        id: &lt;string&gt;,
        name: &lt;string&gt;,
        bio: &lt;string&gt;
    },
    status_code: 200
    message: &lt;string&gt;
}

- &lt;non-200&gt; failed:
{
    data: null,
    status_code: &lt;non-200 status code&gt;
    message: &lt;string_error&gt;
}</code></pre>
<ul>
<li>Delete 1 author by ID</li>
</ul>
<pre><code>DELETE &lt;http://{domain_name}:3000/authors/{author_id}&gt;
* Request:
- Path param:
{
    author_id: &lt;int&gt;
}

* Response: 
- &lt;200&gt; success:
{
    data: {
        id: &lt;string&gt;,
        name: &lt;string&gt;,
        bio: &lt;string&gt;
    },
    status_code: 200
    message: &lt;string&gt;
}
- &lt;non-200&gt; failed:
{
    data: null,
    status_code: &lt;non-200 status code&gt;
    message: &lt;string_error&gt;
}</code></pre>
<ul>
<li>Update 1 book</li>
</ul>
<pre><code>PUT &lt;http://{domain_name}:3000/authors/{authorId}&gt;
* Request:

- Path Param:
{
    authorId: &lt;string&gt;
}

- Headers: 
{
    Content-Type: application/json
}

- Body:
{
    name: &lt;string&gt; - optional,
    bio: &lt;int&gt; - optional,
}

* Response:

- &lt;200&gt; success:
{
    data: null,
    status_code: 200
    message: &lt;string&gt;
}

- &lt;non-200&gt; failed:
{
    data: null,
    status_code: &lt;non-200 status code&gt;
    message: &lt;string_error&gt;
}</code></pre>
